#!/usr/bin/perl
use strict;
use warnings;

# The role of this little script is to preprocess the arguments that would
# normally go to gcc just fine, but which need to be escaped for nvcc. This
# script determines whether it's compiling or linking based on the last
# argument, which will either be a .c file or something else. As such, adding
# the following two lines to your Inline::C config should make this work:
#  CC => '/path/to/perl_nvcc',
#  LD => '/path/to/perl_nvcc',

# First determine if we are compiling or linking.
my $filename = pop @ARGV;
my $stage = 'linker';
if ($filename =~ /\.c$/) {
	# If we're compiling, rename the file so it ends in .cu
	rename $filename, $filename . 'u';
	# Modify the argument list so that the filename extension reflects the newly
	# renamed file.
	$filename .= 'u';
	# Make sure the stage indicates we're compiling:
	$stage = 'compiler';
}

print "perl_nvcc operating as a $stage\n";

# Go through the args and look for non-conformant arguments:
my @extra_options;
my @nvcc_args;

my $next_arg_is_file = 0;

foreach (@ARGV) {
	# First check if the next arg was flagged as a file name, in which case
	# just pass it along.
	print "Analyzing arg [[$_]]...";
	if ($next_arg_is_file) {
		print "apparently an output filename; passing through untouched\n";
		push @nvcc_args, $_;
		$next_arg_is_file = 0;
	}
	elsif (
		# check if it's an nvcc-safe flag or option, and pass it along if so:
		# Make sure the argument is a valid argument. These are the valid flags
		# (i.e. options that do not take values)
		m{^-(?:
			[gGEMcv]|cuda|cubin|fatbin|ptx|gpu|link|lib|pg|shared|noprof
			|foreign|dryrun|keep|clean|deviceemu|use_fast_math
		)$}x
		or
		# These are valid command-line options with associated values, but which
		# don't have an = seperating the option from the value
		m/^-[lLDUIoOm]./
		or
		# These are valid command-line options that have an = seperating the
		# option from the value.
		m{^-(?:
			include|isystem|odir|ccbin|extdeb
			|X(?:compiler|linker|opencc|cudafe|ptxas|fatbin)
			|save-temps|run-args|idp|ddp|dp|arch|code|gencode|dir|ext|int
			|maxrregcount|ftz|prec-div|prec-sqrt
		)=.+/x}
	) {
		print "matches known flag\n";
		push @nvcc_args, $_;
	}
	# Check if this is a bare -o flag, indicating the next argument is the
	# output file
	elsif (/^-o$/) {
		print "is a bare -o; will pass along and include next arg untouched, also\n";
		push @nvcc_args, $_;
		$next_arg_is_file = 1;
	}
	# Otherwise pull it out and add it to the collection of external flags and
	# options.
	elsif (/^-/) {
		print "matches unknown flag; adding it to compiler/linker list\n";
		push @extra_options, $_;
	}
	# If there is no dash, it's just a filename, so pass it along
	else {
		print "not a flag; passing along untouched\n";
		push @nvcc_args, $_;
	}
}

# Set up the flags for the compiler or linker arguments:
my $extra_options = "-X$stage=" . join ',', @extra_options;

# Only add special linker or compiler commands if they exist :-)
unshift @nvcc_args, $extra_options if @extra_options;

# Add the additional arguments.
unshift @nvcc_args, 'nvcc';
push @nvcc_args, $filename;

print "Executing @nvcc_args\n";

system(@nvcc_args);

